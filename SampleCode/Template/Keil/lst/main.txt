; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;406    
;;;407    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;408    {
;;;409    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;410    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;411    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;412    	
;;;413    }
;;;414    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.SPI_Master_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_c
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  SPI_Master_Init PROC
;;;229    
;;;230    void SPI_Master_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;231    {
;;;232    	uint32_t clk_count = SPI_TARGET_FREQ;
000002  4c2b              LDR      r4,|L3.176|
;;;233    	uint8_t u8Item = 0;
;;;234        uint32_t u32Div;
;;;235    
;;;236    	
;;;237        printf("1 ) 8MHz \r\n");
000004  a02b              ADR      r0,|L3.180|
000006  f7fffffe          BL       __2printf
;;;238        printf("2 ) 16MHz \r\n");
00000a  a02d              ADR      r0,|L3.192|
00000c  f7fffffe          BL       __2printf
;;;239        printf("3 ) 24MHz \r\n");
000010  a02f              ADR      r0,|L3.208|
000012  f7fffffe          BL       __2printf
;;;240        printf("4 ) 48MHz \r\n");
000016  a032              ADR      r0,|L3.224|
000018  f7fffffe          BL       __2printf
;;;241        printf("5 ) 60MHz \r\n");
00001c  a034              ADR      r0,|L3.240|
00001e  f7fffffe          BL       __2printf
;;;242        printf("6 ) 72MHz \r\n");	
000022  a037              ADR      r0,|L3.256|
000024  f7fffffe          BL       __2printf
;;;243        printf("7 ) 84MHz \r\n");	
000028  a039              ADR      r0,|L3.272|
00002a  f7fffffe          BL       __2printf
;;;244        printf("8 ) 96MHz \r\n");	
00002e  a03c              ADR      r0,|L3.288|
000030  f7fffffe          BL       __2printf
;;;245    	
;;;246        u8Item = getchar();
000034  483e              LDR      r0,|L3.304|
000036  f7fffffe          BL       getc
00003a  b2c5              UXTB     r5,r0
;;;247        printf("\r\n");
00003c  a03d              ADR      r0,|L3.308|
00003e  f7fffffe          BL       __2printf
;;;248    
;;;249    	
;;;250    	switch(u8Item) 
000042  f1a50031          SUB      r0,r5,#0x31
000046  2808              CMP      r0,#8
000048  d212              BCS      |L3.112|
00004a  e8dff000          TBB      [pc,r0]
00004e  1104              DCB      0x11,0x04
000050  06080a0c          DCB      0x06,0x08,0x0a,0x0c
000054  0e10              DCB      0x0e,0x10
;;;251    	{
;;;252    		case '1':
;;;253    		    clk_count = 8000000ul;
;;;254    		    break;
;;;255    		case '2':
;;;256    		    clk_count = 16000000ul;
000056  4c38              LDR      r4,|L3.312|
;;;257    		    break;
000058  e00a              B        |L3.112|
;;;258    		case '3':
;;;259    		    clk_count = 24000000ul;
00005a  4c38              LDR      r4,|L3.316|
;;;260    		    break;
00005c  e008              B        |L3.112|
;;;261    		case '4':
;;;262    		    clk_count = 48000000ul;
00005e  4c38              LDR      r4,|L3.320|
;;;263    		    break;
000060  e006              B        |L3.112|
;;;264    		case '5':
;;;265    		    clk_count = 60000000ul;
000062  4c38              LDR      r4,|L3.324|
;;;266    		    break;
000064  e004              B        |L3.112|
;;;267    		case '6':
;;;268    		    clk_count = 72000000ul;
000066  4c38              LDR      r4,|L3.328|
;;;269    		    break;
000068  e002              B        |L3.112|
;;;270    		case '7':
;;;271    		    clk_count = 84000000ul;
00006a  4c38              LDR      r4,|L3.332|
;;;272    		    break;
00006c  e000              B        |L3.112|
;;;273    		case '8':
;;;274    		    clk_count = 96000000ul;
00006e  4c38              LDR      r4,|L3.336|
                  |L3.112|
;;;275    		    break;			
;;;276    		default : 
;;;277    			clk_count = SPI_TARGET_FREQ;
;;;278    			break;
;;;279    			
;;;280    	}
;;;281    	
;;;282    	printf("Select : %c , %8d\r\n" , u8Item , clk_count);
000070  4629              MOV      r1,r5
000072  4622              MOV      r2,r4
000074  a037              ADR      r0,|L3.340|
000076  f7fffffe          BL       __2printf
;;;283    
;;;284    
;;;285        SPI_Open(SPI2, SPI_MASTER, SPI_MODE_0, 8, clk_count);
00007a  4d3b              LDR      r5,|L3.360|
00007c  2308              MOVS     r3,#8
00007e  2204              MOVS     r2,#4
000080  2100              MOVS     r1,#0
000082  4628              MOV      r0,r5
000084  9400              STR      r4,[sp,#0]
000086  f7fffffe          BL       SPI_Open
;;;286    	u32Div = (SPI2->CLKDIV & SPI_CLKDIV_DIVIDER_Msk) >> SPI_CLKDIV_DIVIDER_Pos;
00008a  6868              LDR      r0,[r5,#4]
00008c  f3c00408          UBFX     r4,r0,#0,#9
;;;287    	printf("\r\nSPI_GetBusClock : %8d , div : %d\r\n" , SPI_GetBusClock(SPI2) , u32Div);
000090  4628              MOV      r0,r5
000092  f7fffffe          BL       SPI_GetBusClock
000096  4601              MOV      r1,r0
000098  4622              MOV      r2,r4
00009a  a034              ADR      r0,|L3.364|
00009c  f7fffffe          BL       __2printf
;;;288    
;;;289        /* Enable the automatic hardware slave select function. Select the SS pin and configure as low-active. */
;;;290        SPI_EnableAutoSS(SPI2, SPI_SS, SPI_SS_ACTIVE_LOW);
0000a0  4628              MOV      r0,r5
0000a2  e8bd4038          POP      {r3-r5,lr}
0000a6  2200              MOVS     r2,#0
0000a8  2101              MOVS     r1,#1
0000aa  f7ffbffe          B.W      SPI_EnableAutoSS
;;;291    
;;;292    }
;;;293    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L3.176|
                          DCD      0x007a1200
                  |L3.180|
0000b4  31202920          DCB      "1 ) 8MHz \r\n",0
0000b8  384d487a
0000bc  200d0a00
                  |L3.192|
0000c0  32202920          DCB      "2 ) 16MHz \r\n",0
0000c4  31364d48
0000c8  7a200d0a
0000cc  00      
0000cd  00                DCB      0
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L3.208|
0000d0  33202920          DCB      "3 ) 24MHz \r\n",0
0000d4  32344d48
0000d8  7a200d0a
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L3.224|
0000e0  34202920          DCB      "4 ) 48MHz \r\n",0
0000e4  34384d48
0000e8  7a200d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L3.240|
0000f0  35202920          DCB      "5 ) 60MHz \r\n",0
0000f4  36304d48
0000f8  7a200d0a
0000fc  00      
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L3.256|
000100  36202920          DCB      "6 ) 72MHz \r\n",0
000104  37324d48
000108  7a200d0a
00010c  00      
00010d  00                DCB      0
00010e  00                DCB      0
00010f  00                DCB      0
                  |L3.272|
000110  37202920          DCB      "7 ) 84MHz \r\n",0
000114  38344d48
000118  7a200d0a
00011c  00      
00011d  00                DCB      0
00011e  00                DCB      0
00011f  00                DCB      0
                  |L3.288|
000120  38202920          DCB      "8 ) 96MHz \r\n",0
000124  39364d48
000128  7a200d0a
00012c  00      
00012d  00                DCB      0
00012e  00                DCB      0
00012f  00                DCB      0
                  |L3.304|
                          DCD      __stdin
                  |L3.308|
000134  0d0a00            DCB      "\r\n",0
000137  00                DCB      0
                  |L3.312|
                          DCD      0x00f42400
                  |L3.316|
                          DCD      0x016e3600
                  |L3.320|
                          DCD      0x02dc6c00
                  |L3.324|
                          DCD      0x03938700
                  |L3.328|
                          DCD      0x044aa200
                  |L3.332|
                          DCD      0x0501bd00
                  |L3.336|
                          DCD      0x05b8d800
                  |L3.340|
000154  53656c65          DCB      "Select : %c , %8d\r\n",0
000158  6374203a
00015c  20256320
000160  2c202538
000164  640d0a00
                  |L3.360|
                          DCD      0x40063000
                  |L3.364|
00016c  0d0a5350          DCB      "\r\nSPI_GetBusClock : %8d , div : %d\r\n",0
000170  495f4765
000174  74427573
000178  436c6f63
00017c  6b203a20
000180  25386420
000184  2c206469
000188  76203a20
00018c  25640d0a
000190  00      
000191  00                DCB      0
000192  00                DCB      0
000193  00                DCB      0

                          AREA ||i.SPI_Master_PDMA_Enable||, CODE, READONLY, ALIGN=2

                  SPI_Master_PDMA_Enable PROC
;;;194    
;;;195    void SPI_Master_PDMA_Enable(uint8_t TxRx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;196    {
;;;197        uint16_t i = 0;
;;;198        static uint16_t j = 0;
;;;199    
;;;200    	LED_Y = 0;
000004  4c13              LDR      r4,|L4.84|
000006  2300              MOVS     r3,#0
000008  6023              STR      r3,[r4,#0]
;;;201    	
;;;202    	if (TxRx == SPI_TX)
;;;203    	{
;;;204    		//prepare master TX data
;;;205    		g_au8MasterToSlaveTestPattern[0] = 0xAA;
;;;206    		g_au8MasterToSlaveTestPattern[1] = 0xDD;
;;;207    
;;;208    		j = 1;
00000a  2501              MOVS     r5,#1
00000c  b120              CBZ      r0,|L4.24|
;;;209    	    for (i = 2; i < DATA_NUM ; i++)
;;;210    	    {
;;;211    	        g_au8MasterToSlaveTestPattern[i] = (i + 0x10*(j++));
;;;212    	    }
;;;213    		j = 0;
;;;214    	
;;;215    		//TX
;;;216    		SPI_Master_TX_PDMA(g_au8MasterToSlaveTestPattern , DATA_NUM);
;;;217    
;;;218    		LED_Y = 1;
;;;219    		
;;;220    	}
;;;221    	else
;;;222    	{
;;;223    		SPI_Master_RX_PDMA(g_au8MasterRxBuffer,DATA_NUM);		
00000e  2108              MOVS     r1,#8
000010  4811              LDR      r0,|L4.88|
000012  f7fffffe          BL       SPI_Master_RX_PDMA
;;;224    
;;;225    		LED_Y = 1;
000016  e019              B        |L4.76|
                  |L4.24|
000018  4e0f              LDR      r6,|L4.88|
00001a  20aa              MOVS     r0,#0xaa              ;205
00001c  3e08              SUBS     r6,r6,#8              ;205
00001e  f1a60210          SUB      r2,r6,#0x10           ;208
000022  7030              STRB     r0,[r6,#0]            ;205
000024  20dd              MOVS     r0,#0xdd              ;206
000026  7070              STRB     r0,[r6,#1]            ;206
000028  8015              STRH     r5,[r2,#0]            ;208
00002a  2002              MOVS     r0,#2                 ;209
                  |L4.44|
00002c  8811              LDRH     r1,[r2,#0]            ;211  ; j
00002e  eb001701          ADD      r7,r0,r1,LSL #4       ;211
000032  5437              STRB     r7,[r6,r0]            ;211
000034  1c49              ADDS     r1,r1,#1              ;211
000036  1c40              ADDS     r0,r0,#1              ;211
000038  b280              UXTH     r0,r0                 ;209
00003a  8011              STRH     r1,[r2,#0]            ;211
00003c  2808              CMP      r0,#8                 ;209
00003e  d3f5              BCC      |L4.44|
000040  4805              LDR      r0,|L4.88|
000042  8013              STRH     r3,[r2,#0]            ;213
000044  2108              MOVS     r1,#8                 ;216
000046  3808              SUBS     r0,r0,#8              ;216
000048  f7fffffe          BL       SPI_Master_TX_PDMA
                  |L4.76|
00004c  6025              STR      r5,[r4,#0]            ;218
;;;226    	}
;;;227    	
;;;228    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;229    
                          ENDP

000052  0000              DCW      0x0000
                  |L4.84|
                          DCD      0x400049c4
                  |L4.88|
                          DCD      ||.data||+0x18

                          AREA ||i.SPI_Master_RX_PDMA||, CODE, READONLY, ALIGN=2

                  SPI_Master_RX_PDMA PROC
;;;88     
;;;89     void SPI_Master_RX_PDMA(uint8_t* Rx , uint16_t len)
000000  b57c              PUSH     {r2-r6,lr}
;;;90     {
;;;91     	uint32_t u32RegValue = 0;
;;;92     	uint32_t u32Abort = 0;	
;;;93     	
;;;94         PDMA_Open(PDMA, (1 << SPI_MASTER_RX_DMA_CH));
000002  4c22              LDR      r4,|L5.140|
000004  460e              MOV      r6,r1                 ;90
000006  4605              MOV      r5,r0                 ;90
000008  2102              MOVS     r1,#2
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       PDMA_Open
;;;95     
;;;96     	//RX	
;;;97         PDMA_SetTransferCnt(PDMA,SPI_MASTER_RX_DMA_CH, PDMA_WIDTH_8, len);
000010  4633              MOV      r3,r6
000012  2200              MOVS     r2,#0
000014  2101              MOVS     r1,#1
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       PDMA_SetTransferCnt
;;;98         /* Set source/destination address and attributes */
;;;99         PDMA_SetTransferAddr(PDMA,SPI_MASTER_RX_DMA_CH, (uint32_t)&SPI2->RX, PDMA_SAR_FIX, (uint32_t)Rx, PDMA_DAR_INC);
00001c  2600              MOVS     r6,#0
00001e  e9cd5600          STRD     r5,r6,[sp,#0]
000022  f44f7340          MOV      r3,#0x300
000026  4a1a              LDR      r2,|L5.144|
000028  2101              MOVS     r1,#1
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       PDMA_SetTransferAddr
;;;100        /* Set request source; set basic mode. */
;;;101    
;;;102        PDMA_SetTransferMode(PDMA,SPI_MASTER_RX_DMA_CH, PDMA_SPI2_RX, FALSE, 0);
000030  2300              MOVS     r3,#0
000032  221b              MOVS     r2,#0x1b
000034  2101              MOVS     r1,#1
000036  4620              MOV      r0,r4
000038  9600              STR      r6,[sp,#0]
00003a  f7fffffe          BL       PDMA_SetTransferMode
;;;103    	
;;;104        /* Single request type. SPI only support PDMA single request type. */
;;;105        PDMA_SetBurstType(PDMA,SPI_MASTER_RX_DMA_CH, PDMA_REQ_SINGLE, PDMA_BURST_128);
00003e  2300              MOVS     r3,#0
000040  2204              MOVS     r2,#4
000042  2101              MOVS     r1,#1
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       PDMA_SetBurstType
;;;106        /* Disable table interrupt */
;;;107        PDMA->DSCT[SPI_MASTER_RX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
00004a  6920              LDR      r0,[r4,#0x10]
00004c  f0400080          ORR      r0,r0,#0x80
000050  6120              STR      r0,[r4,#0x10]
;;;108    
;;;109        SPI_TRIGGER_RX_PDMA(SPI2);
000052  4c0f              LDR      r4,|L5.144|
000054  3c30              SUBS     r4,r4,#0x30
000056  68e0              LDR      r0,[r4,#0xc]
000058  f0400002          ORR      r0,r0,#2
00005c  60e0              STR      r0,[r4,#0xc]
;;;110    
;;;111        while(1)
;;;112        {
;;;113            /* Get interrupt status */
;;;114            u32RegValue = PDMA_GET_INT_STATUS(PDMA);
;;;115            /* Check the DMA transfer done interrupt flag */
;;;116            if(u32RegValue & PDMA_INTSTS_TDIF_Msk)
;;;117            {
;;;118                /* Check the PDMA transfer done interrupt flags */
;;;119                if((PDMA_GET_TD_STS(PDMA) & (1 << SPI_MASTER_RX_DMA_CH)) == (1 << SPI_MASTER_RX_DMA_CH))
00005e  490d              LDR      r1,|L5.148|
000060  4a0c              LDR      r2,|L5.148|
000062  3108              ADDS     r1,r1,#8
                  |L5.100|
000064  6810              LDR      r0,[r2,#0]            ;114
000066  0783              LSLS     r3,r0,#30             ;116
000068  d5fc              BPL      |L5.100|
00006a  680b              LDR      r3,[r1,#0]
00006c  079b              LSLS     r3,r3,#30
00006e  d506              BPL      |L5.126|
;;;120                {
;;;121                    /* Clear the DMA transfer done flags */
;;;122                    PDMA_CLR_TD_FLAG(PDMA,1 << SPI_MASTER_RX_DMA_CH);
000070  2002              MOVS     r0,#2
000072  6008              STR      r0,[r1,#0]
;;;123                    /* Disable SPI PDMA RX function */
;;;124                    SPI_DISABLE_RX_PDMA(SPI2);
000074  68e0              LDR      r0,[r4,#0xc]
000076  f0200002          BIC      r0,r0,#2
00007a  60e0              STR      r0,[r4,#0xc]
;;;125                    break;
;;;126                }
;;;127    
;;;128                /* Check the DMA transfer abort interrupt flag */
;;;129                if(u32RegValue & PDMA_INTSTS_ABTIF_Msk)
;;;130                {
;;;131                    /* Get the target abort flag */
;;;132                    u32Abort = PDMA_GET_ABORT_STS(PDMA);
;;;133                    /* Clear the target abort flag */
;;;134                    PDMA_CLR_ABORT_FLAG(PDMA,u32Abort);
;;;135                    break;
;;;136                }
;;;137            }
;;;138        }
;;;139    
;;;140    }
00007c  bd7c              POP      {r2-r6,pc}
                  |L5.126|
00007e  07c0              LSLS     r0,r0,#31             ;129
000080  d0f0              BEQ      |L5.100|
000082  4904              LDR      r1,|L5.148|
000084  1d09              ADDS     r1,r1,#4              ;132
000086  6808              LDR      r0,[r1,#0]            ;132
000088  6008              STR      r0,[r1,#0]            ;134
00008a  bd7c              POP      {r2-r6,pc}
;;;141    
                          ENDP

                  |L5.140|
                          DCD      0x40008000
                  |L5.144|
                          DCD      0x40063030
                  |L5.148|
                          DCD      0x4000841c

                          AREA ||i.SPI_Master_TX_PDMA||, CODE, READONLY, ALIGN=2

                  SPI_Master_TX_PDMA PROC
;;;141    
;;;142    void SPI_Master_TX_PDMA(uint8_t* Tx , uint16_t len)
000000  b57c              PUSH     {r2-r6,lr}
;;;143    {
;;;144    	uint32_t u32RegValue = 0;
;;;145    	uint32_t u32Abort = 0;	
;;;146    
;;;147        PDMA_Open(PDMA, (1 << SPI_MASTER_TX_DMA_CH));
000002  4c23              LDR      r4,|L6.144|
000004  460e              MOV      r6,r1                 ;143
000006  4605              MOV      r5,r0                 ;143
000008  2101              MOVS     r1,#1
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       PDMA_Open
;;;148    
;;;149    	//TX
;;;150        PDMA_SetTransferCnt(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_WIDTH_8, len);
000010  2200              MOVS     r2,#0
000012  4633              MOV      r3,r6
000014  4611              MOV      r1,r2
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       PDMA_SetTransferCnt
;;;151        /* Set source/destination address and attributes */
;;;152        PDMA_SetTransferAddr(PDMA,SPI_MASTER_TX_DMA_CH, (uint32_t)Tx, PDMA_SAR_INC, (uint32_t)&SPI2->TX, PDMA_DAR_FIX);
00001c  f44f6140          MOV      r1,#0xc00
000020  481c              LDR      r0,|L6.148|
000022  e9cd0100          STRD     r0,r1,[sp,#0]
000026  2300              MOVS     r3,#0
000028  462a              MOV      r2,r5
00002a  4619              MOV      r1,r3
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       PDMA_SetTransferAddr
;;;153        /* Set request source; set basic mode. */
;;;154    	
;;;155        PDMA_SetTransferMode(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_SPI2_TX, FALSE, 0);
000032  2000              MOVS     r0,#0
000034  4603              MOV      r3,r0
000036  4601              MOV      r1,r0
000038  9000              STR      r0,[sp,#0]
00003a  221a              MOVS     r2,#0x1a
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       PDMA_SetTransferMode
;;;156    	
;;;157        /* Single request type. SPI only support PDMA single request type. */
;;;158        PDMA_SetBurstType(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_REQ_SINGLE, PDMA_BURST_128);
000042  2300              MOVS     r3,#0
000044  2204              MOVS     r2,#4
000046  4619              MOV      r1,r3
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       PDMA_SetBurstType
;;;159        /* Disable table interrupt */
;;;160        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
00004e  6820              LDR      r0,[r4,#0]
000050  f0400080          ORR      r0,r0,#0x80
000054  6020              STR      r0,[r4,#0]
;;;161    
;;;162        SPI_TRIGGER_TX_PDMA(SPI2);
000056  4c0f              LDR      r4,|L6.148|
000058  3c20              SUBS     r4,r4,#0x20
00005a  68e0              LDR      r0,[r4,#0xc]
00005c  f0400001          ORR      r0,r0,#1
000060  60e0              STR      r0,[r4,#0xc]
;;;163    
;;;164        while(1)
;;;165        {
;;;166            /* Get interrupt status */
;;;167            u32RegValue = PDMA_GET_INT_STATUS(PDMA);
;;;168            /* Check the DMA transfer done interrupt flag */
;;;169            if(u32RegValue & PDMA_INTSTS_TDIF_Msk)
;;;170            {
;;;171                /* Check the PDMA transfer done interrupt flags */
;;;172                if((PDMA_GET_TD_STS(PDMA) & (1 << SPI_MASTER_TX_DMA_CH)) == (1 << SPI_MASTER_TX_DMA_CH))
000062  490d              LDR      r1,|L6.152|
000064  4a0c              LDR      r2,|L6.152|
000066  3108              ADDS     r1,r1,#8
                  |L6.104|
000068  6810              LDR      r0,[r2,#0]            ;167
00006a  0783              LSLS     r3,r0,#30             ;169
00006c  d5fc              BPL      |L6.104|
00006e  680b              LDR      r3,[r1,#0]
000070  07db              LSLS     r3,r3,#31
000072  d006              BEQ      |L6.130|
;;;173                {
;;;174                    /* Clear the DMA transfer done flags */
;;;175                    PDMA_CLR_TD_FLAG(PDMA,1 << SPI_MASTER_TX_DMA_CH);
000074  2001              MOVS     r0,#1
000076  6008              STR      r0,[r1,#0]
;;;176                    /* Disable SPI PDMA TX function */
;;;177                    SPI_DISABLE_TX_PDMA(SPI2);
000078  68e0              LDR      r0,[r4,#0xc]
00007a  f0200001          BIC      r0,r0,#1
00007e  60e0              STR      r0,[r4,#0xc]
;;;178                    break;
;;;179                }
;;;180    
;;;181                /* Check the DMA transfer abort interrupt flag */
;;;182                if(u32RegValue & PDMA_INTSTS_ABTIF_Msk)
;;;183                {
;;;184                    /* Get the target abort flag */
;;;185                    u32Abort = PDMA_GET_ABORT_STS(PDMA);
;;;186                    /* Clear the target abort flag */
;;;187                    PDMA_CLR_ABORT_FLAG(PDMA,u32Abort);
;;;188                    break;
;;;189                }
;;;190            }
;;;191        }
;;;192    
;;;193    }
000080  bd7c              POP      {r2-r6,pc}
                  |L6.130|
000082  07c0              LSLS     r0,r0,#31             ;182
000084  d0f0              BEQ      |L6.104|
000086  4904              LDR      r1,|L6.152|
000088  1d09              ADDS     r1,r1,#4              ;185
00008a  6808              LDR      r0,[r1,#0]            ;185
00008c  6008              STR      r0,[r1,#0]            ;187
00008e  bd7c              POP      {r2-r6,pc}
;;;194    
                          ENDP

                  |L6.144|
                          DCD      0x40008000
                  |L6.148|
                          DCD      0x40063020
                  |L6.152|
                          DCD      0x4000841c

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;414    
;;;415    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L7.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L7.10|
;;;416    {
;;;417        /*---------------------------------------------------------------------------------------------------------*/
;;;418        /* Init System Clock                                                                                       */
;;;419        /*---------------------------------------------------------------------------------------------------------*/
;;;420        /* Unlock protected registers */
;;;421        SYS_UnlockReg();
;;;422    
;;;423        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;424        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2540          MOV      r5,#0x40004000
000022  f8d50140          LDR      r0,[r5,#0x140]
000026  f02000f0          BIC      r0,r0,#0xf0
00002a  f8c50140          STR      r0,[r5,#0x140]
;;;425    
;;;426        /* Enable clock source */
;;;427        CLK_EnableXtalRC(CLK_PWRCTL_LIRCEN_Msk|CLK_PWRCTL_HIRCEN_Msk|CLK_PWRCTL_LXTEN_Msk|CLK_PWRCTL_HXTEN_Msk);
00002e  200f              MOVS     r0,#0xf
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;428    
;;;429        /* Waiting for clock source ready */
;;;430        CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk|CLK_STATUS_HIRCSTB_Msk|CLK_STATUS_LXTSTB_Msk|CLK_STATUS_HXTSTB_Msk);
000034  201b              MOVS     r0,#0x1b
000036  f7fffffe          BL       CLK_WaitClockReady
;;;431    
;;;432        /* Set core clock as PLL_CLOCK from PLL */
;;;433    //    CLK_SetCoreClock(FREQ_192MHZ);
;;;434    
;;;435    	#if 1
;;;436        /* Disable PLL first to avoid unstable when setting PLL */
;;;437        CLK_DisablePLL();
00003a  f7fffffe          BL       CLK_DisablePLL
;;;438    
;;;439        /* Set PLL frequency */
;;;440    //    CLK->PLLCTL = (CLK->PLLCTL & ~(0x000FFFFFUL)) | 0x0000421EUL;
;;;441    	CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT , FREQ_192MHZ);
00003e  4926              LDR      r1,|L7.216|
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       CLK_EnablePLL
;;;442    
;;;443        /* Waiting for PLL ready */
;;;444        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
000046  2004              MOVS     r0,#4
000048  f7fffffe          BL       CLK_WaitClockReady
;;;445    
;;;446        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(1));
00004c  2100              MOVS     r1,#0
00004e  2002              MOVS     r0,#2
000050  f7fffffe          BL       CLK_SetHCLK
;;;447    	
;;;448        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;449        CLK->PCLKDIV = (CLK_PCLKDIV_PCLK0DIV2 | CLK_PCLKDIV_PCLK1DIV2);
000054  2011              MOVS     r0,#0x11
000056  f8c40234          STR      r0,[r4,#0x234]
;;;450    	#endif
;;;451    
;;;452        /* Enable UART clock */
;;;453        CLK_EnableModuleClock(UART0_MODULE);
00005a  4e20              LDR      r6,|L7.220|
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       CLK_EnableModuleClock
;;;454    
;;;455        /* Select UART clock source from HXT */
;;;456        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
000062  2200              MOVS     r2,#0
000064  4611              MOV      r1,r2
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       CLK_SetModuleClock
;;;457    
;;;458        CLK_SetModuleClock(SPI2_MODULE, CLK_CLKSEL2_SPI2SEL_PCLK1, MODULE_NoMsk);
00006c  4e1c              LDR      r6,|L7.224|
00006e  2200              MOVS     r2,#0
000070  14e9              ASRS     r1,r5,#19
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       CLK_SetModuleClock
;;;459        CLK_EnableModuleClock(SPI2_MODULE);
000078  4630              MOV      r0,r6
00007a  f7fffffe          BL       CLK_EnableModuleClock
;;;460    
;;;461        CLK_EnableModuleClock(PDMA_MODULE);
00007e  2001              MOVS     r0,#1
000080  f7fffffe          BL       CLK_EnableModuleClock
;;;462    
;;;463        CLK_EnableModuleClock(TMR3_MODULE);
000084  4e17              LDR      r6,|L7.228|
000086  4630              MOV      r0,r6
000088  f7fffffe          BL       CLK_EnableModuleClock
;;;464        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_PCLK1, 0);
00008c  2200              MOVS     r2,#0
00008e  01e9              LSLS     r1,r5,#7
000090  4630              MOV      r0,r6
000092  f7fffffe          BL       CLK_SetModuleClock
;;;465    	
;;;466        /* Update System Core Clock */
;;;467        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;468        SystemCoreClockUpdate();
000096  f7fffffe          BL       SystemCoreClockUpdate
;;;469    
;;;470        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;471        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
00009a  6be0              LDR      r0,[r4,#0x3c]
00009c  f420007f          BIC      r0,r0,#0xff0000
0000a0  63e0              STR      r0,[r4,#0x3c]
;;;472        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
0000a2  6be0              LDR      r0,[r4,#0x3c]
0000a4  f44000cc          ORR      r0,r0,#0x660000
0000a8  63e0              STR      r0,[r4,#0x3c]
;;;473    
;;;474        /* Setup SPI2 multi-function pins */
;;;475        SYS->GPA_MFPH &= ~(SYS_GPA_MFPH_PA8MFP_Msk | SYS_GPA_MFPH_PA9MFP_Msk| SYS_GPA_MFPH_PA10MFP_Msk| SYS_GPA_MFPH_PA11MFP_Msk);	
0000aa  6b60              LDR      r0,[r4,#0x34]
0000ac  f36f000f          BFC      r0,#0,#16
0000b0  6360              STR      r0,[r4,#0x34]
;;;476        SYS->GPA_MFPH |= SYS_GPA_MFPH_PA8MFP_SPI2_MOSI | SYS_GPA_MFPH_PA9MFP_SPI2_MISO | SYS_GPA_MFPH_PA10MFP_SPI2_CLK | SYS_GPA_MFPH_PA11MFP_SPI2_SS;
0000b2  6b60              LDR      r0,[r4,#0x34]
0000b4  f2444144          MOV      r1,#0x4444
0000b8  4308              ORRS     r0,r0,r1
0000ba  6360              STR      r0,[r4,#0x34]
;;;477    
;;;478        /* Enable SPI2 clock pin (PA10) schmitt trigger */
;;;479        PA->SMTEN |= (GPIO_SMTEN_SMTEN8_Msk | GPIO_SMTEN_SMTEN9_Msk | GPIO_SMTEN_SMTEN10_Msk | GPIO_SMTEN_SMTEN11_Msk);
0000bc  6a68              LDR      r0,[r5,#0x24]
0000be  f4406070          ORR      r0,r0,#0xf00
0000c2  6268              STR      r0,[r5,#0x24]
;;;480    
;;;481        /* Enable SPI2 I/O high slew rate */
;;;482    	GPIO_SetSlewCtl(PA, (BIT8 | BIT9 | BIT10 | BIT11), GPIO_SLEWCTL_FAST);
0000c4  2202              MOVS     r2,#2
0000c6  f44f6170          MOV      r1,#0xf00
0000ca  4628              MOV      r0,r5
0000cc  f7fffffe          BL       GPIO_SetSlewCtl
0000d0  2000              MOVS     r0,#0
0000d2  f8c40100          STR      r0,[r4,#0x100]
;;;483    	
;;;484        /* Lock protected registers */
;;;485        SYS_LockReg();
;;;486    }
0000d6  bd70              POP      {r4-r6,pc}
;;;487    
                          ENDP

                  |L7.216|
                          DCD      0x0b71b000
                  |L7.220|
                          DCD      0x57803d10
                  |L7.224|
                          DCD      0x66a0000f
                  |L7.228|
                          DCD      0x5f400005

                          AREA ||i.TIMER3_Init||, CODE, READONLY, ALIGN=2

                  TIMER3_Init PROC
;;;397    
;;;398    void TIMER3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;399    {
;;;400        TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L8.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;401        TIMER_EnableInt(TIMER3);
;;;402        NVIC_EnableIRQ(TMR3_IRQn);	
00001a  2023              MOVS     r0,#0x23
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;403        TIMER_Start(TIMER3);
;;;404    }
000028  bd10              POP      {r4,pc}
;;;405    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40051100

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  TMR3_IRQHandler PROC
;;;373    
;;;374    void TMR3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
000002  4815              LDR      r0,|L9.88|
000004  6881              LDR      r1,[r0,#8]
000006  f3c10100          UBFX     r1,r1,#0,#1
;;;375    {
00000a  2900              CMP      r1,#0
00000c  d023              BEQ      |L9.86|
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;376    	static uint16_t CNT = 0;	
;;;377    	static uint32_t log = 0;	
;;;378    	
;;;379        if(TIMER_GetIntFlag(TIMER3) == 1)
;;;380        {
;;;381            TIMER_ClearIntFlag(TIMER3);
;;;382    		tick_counter();
000012  f7fffffe          BL       tick_counter
000016  4b11              LDR      r3,|L9.92|
;;;383    
;;;384    		if ((get_tick() % 10) == 0)
000018  210a              MOVS     r1,#0xa
00001a  6898              LDR      r0,[r3,#8]  ; conter_tick
00001c  fbb0f2f1          UDIV     r2,r0,r1
000020  fb010012          MLS      r0,r1,r2,r0
000024  b918              CBNZ     r0,|L9.46|
;;;385    		{
;;;386    			set_flag(flag_SPI_Transmit_timing , ENABLE);
000026  6858              LDR      r0,[r3,#4]  ; BitFlag
000028  f0400002          ORR      r0,r0,#2
00002c  6058              STR      r0,[r3,#4]  ; BitFlag
                  |L9.46|
;;;387    		}
;;;388    	
;;;389    		if (CNT++ > 1000)
00002e  8858              LDRH     r0,[r3,#2]  ; CNT
000030  1c41              ADDS     r1,r0,#1
000032  8059              STRH     r1,[r3,#2]
000034  f5b07f7a          CMP      r0,#0x3e8
000038  d90d              BLS      |L9.86|
;;;390    		{		
;;;391    			CNT = 0;
00003a  2000              MOVS     r0,#0
00003c  8058              STRH     r0,[r3,#2]
;;;392    			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
00003e  68da              LDR      r2,[r3,#0xc]  ; log
000040  4907              LDR      r1,|L9.96|
000042  1c50              ADDS     r0,r2,#1
000044  60d8              STR      r0,[r3,#0xc]  ; log
000046  a007              ADR      r0,|L9.100|
000048  f7fffffe          BL       __2printf
;;;393    			LED_R ^= 1;
00004c  4808              LDR      r0,|L9.112|
00004e  6801              LDR      r1,[r0,#0]
000050  f0810101          EOR      r1,r1,#1
000054  6001              STR      r1,[r0,#0]
                  |L9.86|
;;;394    		}
;;;395        }
;;;396    }
000056  bd10              POP      {r4,pc}
;;;397    
                          ENDP

                  |L9.88|
                          DCD      0x40051100
                  |L9.92|
                          DCD      ||.data||
                  |L9.96|
                          DCD      ||.constdata||+0xe
                  |L9.100|
000064  2573203a          DCB      "%s : %2d\r\n",0
000068  20253264
00006c  0d0a00  
00006f  00                DCB      0
                  |L9.112|
                          DCD      0x400049c0

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;327    
;;;328    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;329    {
;;;330        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L10.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  f4105f88          TST      r0,#0x1100
00000a  d102              BNE      |L10.18|
00000c  e004              B        |L10.24|
                  |L10.14|
;;;331        {
;;;332            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;333            {
;;;334    			UARTx_Process();
00000e  f7fffffe          BL       UARTx_Process
                  |L10.18|
000012  69a1              LDR      r1,[r4,#0x18]         ;332
000014  0449              LSLS     r1,r1,#17             ;332
000016  d5fa              BPL      |L10.14|
                  |L10.24|
;;;335            }
;;;336        }
;;;337    
;;;338        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
000018  69a1              LDR      r1,[r4,#0x18]
00001a  4620              MOV      r0,r4
00001c  f0110f71          TST      r1,#0x71
000020  d005              BEQ      |L10.46|
;;;339        {
;;;340            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000022  e8bd4010          POP      {r4,lr}
000026  f44f5110          MOV      r1,#0x2400
00002a  f7ffbffe          B.W      UART_ClearIntFlag
                  |L10.46|
;;;341        }
;;;342    }
00002e  bd10              POP      {r4,pc}
;;;343    
                          ENDP

                  |L10.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;345    
;;;346    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;347    {
;;;348        SYS_ResetModule(UART0_RST);
000002  4824              LDR      r0,|L11.148|
000004  f7fffffe          BL       SYS_ResetModule
;;;349    
;;;350        /* Configure UART0 and set UART0 baud rate */
;;;351        UART_Open(UART0, 115200);
000008  4c23              LDR      r4,|L11.152|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;352    
;;;353    	/* Set UART receive time-out */
;;;354    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;355    
;;;356    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  f0200010          BIC      r0,r0,#0x10
000022  60a0              STR      r0,[r4,#8]
;;;357    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  f0400020          ORR      r0,r0,#0x20
00002a  60a0              STR      r0,[r4,#8]
;;;358    
;;;359    	/* Enable UART Interrupt - */
;;;360    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  f6400111          MOV      r1,#0x811
000032  4308              ORRS     r0,r0,r1
000034  6060              STR      r0,[r4,#4]
;;;361    	
;;;362    	NVIC_EnableIRQ(UART0_IRQn);
000036  2024              MOVS     r0,#0x24
000038  f7fffffe          BL       NVIC_EnableIRQ
;;;363    
;;;364    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003c  f7fffffe          BL       CLK_GetCPUFreq
000040  4601              MOV      r1,r0
000042  a016              ADR      r0,|L11.156|
000044  f7fffffe          BL       __2printf
;;;365    	printf("CLK_GetPLLClockFreq : %8d\r\n",CLK_GetPLLClockFreq());
000048  f7fffffe          BL       CLK_GetPLLClockFreq
00004c  4601              MOV      r1,r0
00004e  a01a              ADR      r0,|L11.184|
000050  f7fffffe          BL       __2printf
;;;366    	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());	
000054  f7fffffe          BL       CLK_GetHCLKFreq
000058  4601              MOV      r1,r0
00005a  a01e              ADR      r0,|L11.212|
00005c  f7fffffe          BL       __2printf
;;;367    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000060  f7fffffe          BL       CLK_GetHXTFreq
000064  4601              MOV      r1,r0
000066  a021              ADR      r0,|L11.236|
000068  f7fffffe          BL       __2printf
;;;368    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
00006c  f7fffffe          BL       CLK_GetLXTFreq
000070  4601              MOV      r1,r0
000072  a024              ADR      r0,|L11.260|
000074  f7fffffe          BL       __2printf
;;;369    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000078  f7fffffe          BL       CLK_GetPCLK0Freq
00007c  4601              MOV      r1,r0
00007e  a027              ADR      r0,|L11.284|
000080  f7fffffe          BL       __2printf
;;;370    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
000084  f7fffffe          BL       CLK_GetPCLK1Freq
000088  4601              MOV      r1,r0
00008a  e8bd4010          POP      {r4,lr}
00008e  a02a              ADR      r0,|L11.312|
000090  f7ffbffe          B.W      __2printf
;;;371    }
;;;372    
                          ENDP

                  |L11.148|
                          DCD      0x04000010
                  |L11.152|
                          DCD      0x40070000
                  |L11.156|
00009c  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
0000a0  4b5f4765
0000a4  74435055
0000a8  46726571
0000ac  203a2025
0000b0  38640d0a
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L11.184|
0000b8  434c4b5f          DCB      "CLK_GetPLLClockFreq : %8d\r\n",0
0000bc  47657450
0000c0  4c4c436c
0000c4  6f636b46
0000c8  72657120
0000cc  3a202538
0000d0  640d0a00
                  |L11.212|
0000d4  434c4b5f          DCB      "CLK_GetHCLKFreq : %8d\r\n",0
0000d8  47657448
0000dc  434c4b46
0000e0  72657120
0000e4  3a202538
0000e8  640d0a00
                  |L11.236|
0000ec  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000f0  47657448
0000f4  58544672
0000f8  6571203a
0000fc  20253864
000100  0d0a00  
000103  00                DCB      0
                  |L11.260|
000104  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
000108  4765744c
00010c  58544672
000110  6571203a
000114  20253864
000118  0d0a00  
00011b  00                DCB      0
                  |L11.284|
00011c  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
000120  47657450
000124  434c4b30
000128  46726571
00012c  203a2025
000130  38640d0a
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0
                  |L11.312|
000138  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
00013c  47657450
000140  434c4b31
000144  46726571
000148  203a2025
00014c  38640d0a
000150  00      
000151  00                DCB      0
000152  00                DCB      0
000153  00                DCB      0

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_s
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                  UARTx_Process PROC
;;;293    
;;;294    void UARTx_Process(void)
000000  b510              PUSH     {r4,lr}
;;;295    {
;;;296    	uint8_t res = 0;
;;;297    	
;;;298    	res = UART_READ(UART0);
000002  4814              LDR      r0,|L12.84|
000004  6800              LDR      r0,[r0,#0]
;;;299    
;;;300    	printf("%s  : 0x%2X\r\n" , __FUNCTION__ ,res);
000006  4914              LDR      r1,|L12.88|
000008  b2c4              UXTB     r4,r0                 ;298
00000a  4622              MOV      r2,r4
00000c  a013              ADR      r0,|L12.92|
00000e  f7fffffe          BL       __2printf
;;;301    
;;;302    	if (res > 0x7F)
000012  2c7f              CMP      r4,#0x7f
000014  d904              BLS      |L12.32|
;;;303    	{
;;;304    		printf("invalid command\r\n");
000016  e8bd4010          POP      {r4,lr}
00001a  a014              ADR      r0,|L12.108|
00001c  f7ffbffe          B.W      __2printf
                  |L12.32|
;;;305    	}
;;;306    	else
;;;307    	{
;;;308    		switch(res)
000020  2c5a              CMP      r4,#0x5a
000022  d009              BEQ      |L12.56|
000024  dc04              BGT      |L12.48|
000026  2c31              CMP      r4,#0x31
000028  d013              BEQ      |L12.82|
00002a  2c58              CMP      r4,#0x58
00002c  d111              BNE      |L12.82|
00002e  e003              B        |L12.56|
                  |L12.48|
000030  2c78              CMP      r4,#0x78
000032  d001              BEQ      |L12.56|
000034  2c7a              CMP      r4,#0x7a
000036  d10c              BNE      |L12.82|
                  |L12.56|
000038  f3bf8f4f          DSB      
00003c  4810              LDR      r0,|L12.128|
00003e  6801              LDR      r1,[r0,#0]
000040  4a10              LDR      r2,|L12.132|
000042  f40161e0          AND      r1,r1,#0x700
000046  4311              ORRS     r1,r1,r2
000048  6001              STR      r1,[r0,#0]
00004a  f3bf8f4f          DSB      
                  |L12.78|
00004e  bf00              NOP      
000050  e7fd              B        |L12.78|
                  |L12.82|
;;;309    		{
;;;310    	
;;;311    			case '1':
;;;312    
;;;313    				break;	
;;;314    
;;;315    			case 'X':
;;;316    			case 'x':
;;;317    			case 'Z':
;;;318    			case 'z':
;;;319    			
;;;320    				NVIC_SystemReset();
;;;321    			
;;;322    				break;		
;;;323    			
;;;324    		}
;;;325    	}
;;;326    }
000052  bd10              POP      {r4,pc}
;;;327    
                          ENDP

                  |L12.84|
                          DCD      0x40070000
                  |L12.88|
                          DCD      ||.constdata||
                  |L12.92|
00005c  25732020          DCB      "%s  : 0x%2X\r\n",0
000060  3a203078
000064  2532580d
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L12.108|
00006c  696e7661          DCB      "invalid command\r\n",0
000070  6c696420
000074  636f6d6d
000078  616e640d
00007c  0a00    
00007e  00                DCB      0
00007f  00                DCB      0
                  |L12.128|
                          DCD      0xe000ed0c
                  |L12.132|
                          DCD      0x05fa0004

                          AREA ||i.dump_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dump_buffer PROC
;;;55     
;;;56     void dump_buffer(uint8_t *pucBuff, int nBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;57     {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;58         uint16_t i = 0;
000006  2400              MOVS     r4,#0
;;;59         
;;;60         printf("dump_buffer : %2d\r\n" , nBytes);    
000008  a00b              ADR      r0,|L13.56|
00000a  f7fffffe          BL       __2printf
;;;61         for (i = 0 ; i < nBytes ; i++)
00000e  e00c              B        |L13.42|
                  |L13.16|
;;;62         {
;;;63             printf("0x%2X," , pucBuff[i]);
000010  5d31              LDRB     r1,[r6,r4]
000012  a00e              ADR      r0,|L13.76|
000014  f7fffffe          BL       __2printf
;;;64             if ((i+1)%8 ==0)
000018  0760              LSLS     r0,r4,#29
00001a  f1b04f60          CMP      r0,#0xe0000000
00001e  d102              BNE      |L13.38|
;;;65             {
;;;66                 printf("\r\n");
000020  a00c              ADR      r0,|L13.84|
000022  f7fffffe          BL       __2printf
                  |L13.38|
000026  1c64              ADDS     r4,r4,#1
000028  b2a4              UXTH     r4,r4                 ;61
                  |L13.42|
00002a  42ac              CMP      r4,r5                 ;61
00002c  dbf0              BLT      |L13.16|
;;;67             }            
;;;68         }
;;;69         printf("\r\n\r\n");
00002e  e8bd4070          POP      {r4-r6,lr}
000032  a009              ADR      r0,|L13.88|
000034  f7ffbffe          B.W      __2printf
;;;70     }
;;;71     
                          ENDP

                  |L13.56|
000038  64756d70          DCB      "dump_buffer : %2d\r\n",0
00003c  5f627566
000040  66657220
000044  3a202532
000048  640d0a00
                  |L13.76|
00004c  30782532          DCB      "0x%2X,",0
000050  582c00  
000053  00                DCB      0
                  |L13.84|
000054  0d0a00            DCB      "\r\n",0
000057  00                DCB      0
                  |L13.88|
000058  0d0a0d0a          DCB      "\r\n\r\n",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;77     
;;;78     uint32_t get_tick(void)
000000  4801              LDR      r0,|L14.8|
;;;79     {
;;;80     	return (conter_tick);
000002  6880              LDR      r0,[r0,#8]  ; conter_tick
;;;81     }
000004  4770              BX       lr
;;;82     
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;495    
;;;496    int main()
000000  f7fffffe          BL       SYS_Init
;;;497    {
;;;498    	
;;;499        SYS_Init();
;;;500        /* Init UART to 115200-8n1 for print message */
;;;501    	UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;502    
;;;503    	SPI_Master_Init();
000008  f7fffffe          BL       SPI_Master_Init
;;;504    
;;;505    	LED_Init();
00000c  f7fffffe          BL       LED_Init
;;;506    	TIMER3_Init();
000010  f7fffffe          BL       TIMER3_Init
;;;507    	
;;;508        /* Got no where to go, just loop forever */
;;;509        while(1)
;;;510        {
;;;511    //		TIMER0_Polling(100);
;;;512    
;;;513    		if (is_flag_set(flag_SPI_Transmit_timing))	
000014  4c07              LDR      r4,|L15.52|
                  |L15.22|
000016  6860              LDR      r0,[r4,#4]  ; BitFlag
000018  0780              LSLS     r0,r0,#30
00001a  d5fc              BPL      |L15.22|
;;;514    //		if (is_flag_set(flag_SPI_Transmit_finish))	
;;;515    		{
;;;516    			set_flag(flag_SPI_Transmit_timing , DISABLE);
00001c  6860              LDR      r0,[r4,#4]  ; BitFlag
00001e  f0200002          BIC      r0,r0,#2
000022  6060              STR      r0,[r4,#4]  ; BitFlag
;;;517    			set_flag(flag_SPI_Transmit_finish , DISABLE);
000024  6860              LDR      r0,[r4,#4]  ; BitFlag
000026  f0200004          BIC      r0,r0,#4
00002a  6060              STR      r0,[r4,#4]  ; BitFlag
;;;518    			
;;;519    //			SPI_Master_PDMA_Enable(SPI_RX);
;;;520    			SPI_Master_PDMA_Enable(SPI_TX);
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       SPI_Master_PDMA_Enable
000032  e7f0              B        |L15.22|
;;;521    		}
;;;522    
;;;523        }
;;;524    
;;;525    }
;;;526    
                          ENDP

                  |L15.52|
                          DCD      ||.data||

                          AREA ||i.set_tick||, CODE, READONLY, ALIGN=2

                  set_tick PROC
;;;82     
;;;83     void set_tick(uint32_t t)
000000  4901              LDR      r1,|L16.8|
;;;84     {
;;;85     	conter_tick = t;
000002  6088              STR      r0,[r1,#8]  ; conter_tick
;;;86     }
000004  4770              BX       lr
;;;87     
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      ||.data||

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;72     
;;;73     void tick_counter(void)
000000  4802              LDR      r0,|L17.12|
;;;74     {
;;;75     	conter_tick++;
000002  6881              LDR      r1,[r0,#8]  ; conter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6081              STR      r1,[r0,#8]  ; conter_tick
;;;76     }
000008  4770              BX       lr
;;;77     
                          ENDP

00000a  0000              DCW      0x0000
                  |L17.12|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  55415254          DCB      0x55,0x41,0x52,0x54
000004  785f5072          DCB      0x78,0x5f,0x50,0x72
000008  6f636573          DCB      0x6f,0x63,0x65,0x73
00000c  7300              DCB      0x73,0x00
                  |symbol_number.60|
00000e  544d              DCB      0x54,0x4d
000010  52335f49          DCB      0x52,0x33,0x5f,0x49
000014  52514861          DCB      0x52,0x51,0x48,0x61
000018  6e646c65          DCB      0x6e,0x64,0x6c,0x65
00001c  7200              DCB      0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  j
000000  0000              DCW      0x0000
                  ||CNT||
000002  0000              DCW      0x0000
                  BitFlag
                          DCD      0x00000000
                  conter_tick
                          DCD      0x00000000
                  log
                          DCD      0x00000000
                  g_au8MasterToSlaveTestPattern
000010  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                  g_au8MasterRxBuffer
000018  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000

                          AREA ||area_number.22||, DATA, ALIGN=0

                          EXPORTAS ||area_number.22||, ||.data||
                  g_au8SlaveToMasterTestPattern
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCDU     0x00000000

                          AREA ||area_number.23||, DATA, ALIGN=0

                          EXPORTAS ||area_number.23||, ||.data||
                  g_au8SlaveRxBuffer
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCDU     0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_468c6c6b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____REVSH|
#line 402
|__asm___6_main_c_468c6c6b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____RRX|
#line 587
|__asm___6_main_c_468c6c6b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
